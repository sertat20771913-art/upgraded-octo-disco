
<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>AhhWeather — Liquid Glass Gauges</title>
<meta name="description" content="Погода: liquid glass UI + реальные данные Open-Meteo + спидометры" />
<style>
  /* ---------- vars ---------- */
  :root{
    --bg-1: #07121a;
    --bg-2: #0b2430;
    --glass-bg: rgba(255,255,255,0.06);
    --glass-border: rgba(255,255,255,0.08);
    --muted: #9fb3bd;
    --accent: #4ca1af;
    --danger: #ff6b6b;
    --cold: #45b0ff;
    --trans: 420ms cubic-bezier(.2,.9,.2,1);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter, "SF Pro Display", system-ui, -apple-system, Roboto, "Segoe UI", Arial; -webkit-font-smoothing:antialiased}
  body{
    background: linear-gradient(180deg,var(--bg-1),var(--bg-2));
    color: #e8f3f2;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:24px;
    overflow:hidden;
  }

  /* ---------- app layout ---------- */
  .app{
    width:100%; max-width:1200px;
    display:grid;
    grid-template-columns: 1fr 380px;
    gap:24px;
    align-items:start;
    transform: translateZ(0);
  }
  @media (max-width:980px){ .app{ grid-template-columns:1fr; } }

  /* ---------- scene (left) ---------- */
  .scene{
    position:relative;
    border-radius:18px;
    min-height:620px;
    overflow:hidden;
    box-shadow: 0 26px 80px rgba(2,8,15,0.6);
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  }
  /* stacked canvases for layering */
  .scene canvas{ position:absolute; inset:0; width:100%; height:100%; display:block; }

  /* ---------- liquid glass gauge container ---------- */
  .gauge-wrap{
    position: absolute;
    left: 50%;
    top: 48%;
    transform: translate(-50%,-48%);
    z-index: 40;
    width: 720px;
    max-width: 92%;
    display: grid;
    grid-template-columns: 1fr 300px;
    gap: 18px;
    padding: 18px;
    border-radius: 16px;
    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
    border: 1px solid var(--glass-border);
    backdrop-filter: blur(10px) saturate(140%);
    box-shadow: 0 10px 40px rgba(0,0,0,0.45);
  }
  @media (max-width:880px){ .gauge-wrap{ grid-template-columns:1fr; width:92%; } }

  /* ---------- left big gauge block ---------- */
  .main-gauge{
    padding:12px; display:flex; flex-direction:column; gap:8px; align-items:center; justify-content:center;
  }
  .place-row{ width:100%; display:flex; justify-content:space-between; align-items:center }
  .place{ font-weight:700; font-size:20px }
  .small{ font-size:13px; color:var(--muted) }

  .gauge-svg{ width:100%; height:320px; display:block; }
  .temp-center{ font-size:40px; font-weight:800; margin-top:-18px; text-align:center; letter-spacing:-0.6px; }

  /* ---------- right detail column (mini gauges + controls) ---------- */
  .side-panel{ padding:6px; display:flex; flex-direction:column; gap:10px; align-items:stretch; }
  .chips{ display:flex; gap:8px; flex-wrap:wrap }
  .chip{ padding:8px 12px; border-radius:999px; background:rgba(255,255,255,0.02); color:var(--muted); font-size:13px }

  .mini-gauges{ display:grid; grid-template-columns:1fr 1fr; gap:10px }
  .mini{ background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:12px; padding:12px; display:flex; flex-direction:column; align-items:center; gap:8px; border:1px solid rgba(255,255,255,0.03); cursor:pointer; transition:transform 180ms; }
  .mini:active{ transform: translateY(2px) }
  .mini .label{ font-size:12px; color:var(--muted) }
  .mini .val{ font-weight:800; font-size:18px }

  .controls{ display:flex; gap:8px; margin-top:6px }
  input[type=text]{ flex:1; padding:10px 12px; border-radius:10px; border:none; background:rgba(255,255,255,0.02); color:inherit }
  button{ padding:10px 12px; border-radius:10px; border:none; background:linear-gradient(180deg,var(--accent), #2b8e88); color:#022; cursor:pointer }

  .loader{ width:28px; height:28px; border-radius:50%; border:4px solid rgba(255,255,255,0.06); border-top-color:var(--accent); animation:spin 900ms linear infinite; display:inline-block }
  @keyframes spin{ to{ transform:rotate(360deg) } }

  /* ---------- expanded modal card ---------- */
  .expanded{ position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); z-index:1500; width:420px; max-width:92%; padding:18px; border-radius:14px; background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02)); backdrop-filter:blur(12px); border:1px solid rgba(255,255,255,0.06); box-shadow: 0 30px 80px rgba(0,0,0,0.6); }
  .close-x{ position:absolute; right:14px; top:10px; cursor:pointer; color:var(--muted) }

  /* ---------- footer ---------- */
  .footer { margin-top:8px; text-align:center; font-size:12px; color:var(--muted) }

  /* responsive */
  @media (max-width:520px){
    .gauge-svg{ height:260px; }
    .temp-center{ font-size:30px }
  }
</style>

<!-- SVG filters for subtle liquid effect (noise + displacement) -->
<svg style="position:absolute;width:0;height:0;pointer-events:none" aria-hidden="true">
  <filter id="noise" x="0" y="0" width="100%" height="100%">
    <feTurbulence baseFrequency="0.8" numOctaves="2" stitchTiles="stitch" result="t" />
    <feColorMatrix type="saturate" values="0" />
    <feBlend in="SourceGraphic" in2="t" mode="overlay"/>
  </filter>
  <filter id="disp" x="-20%" y="-20%" width="140%" height="140%">
    <feTurbulence baseFrequency="0.002" numOctaves="3" seed="2" result="noise" />
    <feDisplacementMap in="SourceGraphic" in2="noise" scale="6" xChannelSelector="R" yChannelSelector="G" />
  </filter>
</svg>

<body>
  <div class="app" role="application" aria-label="AhhWeather Liquid Glass">

    <!-- LEFT: Scene with canvases and big glass gauge -->
    <section class="scene" id="scene">
      <canvas id="sky"></canvas>
      <canvas id="clouds"></canvas>
      <canvas id="precip"></canvas>
      <canvas id="flash"></canvas>

      <div class="gauge-wrap" id="gaugeWrap">
        <div class="main-gauge">
          <div class="place-row">
            <div>
              <div class="small">Погода</div>
              <div class="place" id="place">—</div>
            </div>
            <div id="loader" style="display:none"><span class="loader"></span></div>
          </div>

          <!-- BIG SVG GAUGE: center at (180,180) -->
          <svg class="gauge-svg" viewBox="0 0 360 220" id="gaugeSVG" aria-hidden="true">
            <defs>
              <linearGradient id="gradTemp" x1="0" x2="1">
                <stop offset="0%" stop-color="#4fb3ff"/>
                <stop offset="50%" stop-color="#7ef0b8"/>
                <stop offset="100%" stop-color="#ff6b6b"/>
              </linearGradient>
            </defs>

            <g transform="translate(180,180)">
              <path id="arc-bg" d="" fill="none" stroke="rgba(255,255,255,0.06)" stroke-width="18" stroke-linecap="round"></path>
              <path id="arc-fill" d="" fill="none" stroke="url(#gradTemp)" stroke-width="18" stroke-linecap="round" stroke-linejoin="round"></path>
              <g id="ticks"></g>
              <g id="needleG" transform="rotate(0)">
                <line x1="0" y1="0" x2="0" y2="-88" stroke="#fff" stroke-width="3" stroke-linecap="round" />
                <circle r="6" fill="#fff"></circle>
              </g>
            </g>
          </svg>

          <div class="temp-center" id="tempCenter">—°C</div>
          <div class="small" id="weatherLabel">—</div>
        </div>

        <!-- RIGHT column: mini-gauges + controls -->
        <div class="side-panel">
          <div class="chips">
            <div class="chip" id="chipTime">—</div>
            <div class="chip" id="chipCond">—</div>
          </div>

          <div class="mini-gauges">
            <div class="mini" data-key="humidity" id="miniHumidity">
              <div class="label">Влажность</div>
              <div class="val" id="miniValHum">—%</div>
              <svg viewBox="0 0 100 100" width="84" height="84" id="gHum"></svg>
            </div>

            <div class="mini" data-key="pressure" id="miniPressure">
              <div class="label">Давление</div>
              <div class="val" id="miniValPres">— hPa</div>
              <svg viewBox="0 0 100 100" width="84" height="84" id="gPres"></svg>
            </div>

            <div class="mini" data-key="wind" id="miniWind">
              <div class="label">Ветер</div>
              <div class="val" id="miniValWind">— м/с</div>
              <svg viewBox="0 0 100 100" width="84" height="84" id="gWind"></svg>
            </div>

            <div class="mini" data-key="feels" id="miniFeels">
              <div class="label">Ощущается</div>
              <div class="val" id="miniValFeels">—°C</div>
              <svg viewBox="0 0 100 100" width="84" height="84" id="gFeels"></svg>
            </div>
          </div>

          <div class="controls">
            <input id="cityInput" type="text" placeholder="Город (оставьте пустым — геолокация)"/>
            <button id="btnFetch">Показать</button>
          </div>

          <div class="slider-row" style="display:flex;align-items:center;justify-content:space-between;margin-top:8px">
            <label class="small"><input id="unitSwitch" type="checkbox"> °F</label>
            <label class="small"><input id="autoTheme" type="checkbox" checked> Авто день/ночь</label>
          </div>

          <div class="footer">Данные: Open-Meteo · UI: Liquid Glass</div>
        </div>
      </div>
    </section>

    <!-- RIGHT: optional details panel (kept simple) -->
    <aside style="padding:8px;display:flex;flex-direction:column;gap:10px">
      <div style="background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:12px; border-radius:12px; border:1px solid rgba(255,255,255,0.03)">
        <div style="font-size:14px;color:var(--muted)">Последние данные</div>
        <div style="font-weight:700;font-size:20px;margin-top:6px" id="summaryTemp">—</div>
        <div style="margin-top:6px" id="summaryText">—</div>
      </div>

      <div style="background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:12px; border-radius:12px; border:1px solid rgba(255,255,255,0.03)">
        <div style="font-size:13px;color:var(--muted)">Сцена</div>
        <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
          <select id="sceneSelect" style="flex:1;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);border:none;color:inherit">
            <option value="auto">Авто</option>
            <option value="clear">Ясно</option>
            <option value="cloudy">Облачно</option>
            <option value="rain">Дождь</option>
            <option value="thunder">Гроза</option>
            <option value="snow">Снег</option>
          </select>
          <button id="refreshBtn" title="Обновить">⟳</button>
        </div>
      </div>

      <div style="font-size:12px;color:var(--muted);">Сайт работает целиком в браузере. Для AccuWeather/NarodMon потребуется API и прокси.</div>
    </aside>
  </div>

<script>
/* ============================
  Liquid Glass Gauges — Full Script
  - Open-Meteo real data (current + hourly humidity/pressure)
  - Big temperature gauge (−25..+40) + 4 mini gauges
  - Geolocation fallback to manual city
  - Scene: sky, clouds, precip, lightning
  - Liquid glass: CSS + subtle SVG noise/displacement in style
============================ */

const $ = s => document.querySelector(s);

/* Canvas + contexts */
const canv = {
  sky: $('#sky'),
  clouds: $('#clouds'),
  precip: $('#precip'),
  flash: $('#flash')
};
const ctx = {
  sky: canv.sky.getContext('2d'),
  clouds: canv.clouds.getContext('2d'),
  precip: canv.precip.getContext('2d'),
  flash: canv.flash.getContext('2d')
};

/* DPR & resize */
let DPR = Math.max(1, window.devicePixelRatio || 1);
function resizeAll(){
  DPR = Math.max(1, window.devicePixelRatio || 1);
  for(const c of Object.values(canv)){
    c.width = Math.floor(c.clientWidth * DPR) || Math.floor(window.innerWidth * DPR);
    c.height = Math.floor(c.clientHeight * DPR) || Math.floor(window.innerHeight * DPR);
    c.style.width = '';
    c.style.height = '';
  }
  cloudField.onResize();
  precip.onResize();
  drawSky();
}
window.addEventListener('resize', debounce(()=>resizeAll(), 160));
resizeAll();

/* Sky gradient */
let skyState = {mode:'night'}; // day/dusk/night
function drawSky(){
  const c = ctx.sky; const w=c.canvas.width, h=c.canvas.height;
  c.clearRect(0,0,w,h);
  const g = c.createLinearGradient(0,0,0,h);
  if(skyState.mode==='day'){ g.addColorStop(0,'#a7e9dc'); g.addColorStop(1,'#cfe0ff'); }
  else if(skyState.mode==='dusk'){ g.addColorStop(0,'#ffd89b'); g.addColorStop(1,'#19547b'); }
  else { g.addColorStop(0,'#020617'); g.addColorStop(1,'#07121a'); }
  c.fillStyle = g; c.fillRect(0,0,w,h);
}

/* Clouds: soft radial blobs */
const cloudField = (() => {
  let items = [], density=12;
  function init(){
    const canvas = ctx.clouds.canvas; const W=canvas.width, H=canvas.height;
    items=[];
    const count = Math.max(6, Math.min(30, Math.floor(density * (W/1200))));
    for(let i=0;i<count;i++){
      items.push({ x: Math.random()*W, y: Math.random()*H*0.5 + H*0.05, size: 90 + Math.random()*300, vx: 0.02 + Math.random()*0.18, alpha: 0.06 + Math.random()*0.2, wobble: Math.random()*Math.PI*2 });
    }
  }
  function onResize(){ init(); }
  function drawOne(cctx,x,y,size,alpha){
    cctx.save(); cctx.globalAlpha=alpha;
    const grad = cctx.createRadialGradient(x,y,size*0.12,x,y,size);
    grad.addColorStop(0,'rgba(255,255,255,0.95)');
    grad.addColorStop(0.45,'rgba(255,255,255,0.6)');
    grad.addColorStop(1,'rgba(255,255,255,0)');
    cctx.fillStyle = grad; cctx.beginPath(); cctx.ellipse(x,y,size*1.05,size*0.6,0,0,Math.PI*2); cctx.fill();
    cctx.restore();
  }
  init();
  return { update(dt){
      const c = ctx.clouds; c.clearRect(0,0,c.canvas.width,c.canvas.height);
      for(const p of items){
        p.x += p.vx * dt * DPR; p.wobble += 0.001*dt; p.y += Math.sin(p.wobble)*0.02*DPR;
        if(p.x - p.size > c.canvas.width) p.x = -p.size;
        drawOne(c, p.x, p.y, p.size, p.alpha);
      }
    }, onResize };
})();

/* Precipitation system */
const precip = (() => {
  let particles=[], mode='none';
  function setMode(m){ mode=m; reset(); }
  function reset(){
    particles=[]; const c=ctx.precip.canvas; const W=c.width, H=c.height;
    const base = (W>1400)?240: (W>900)?140:80;
    const count = Math.max(20, Math.min(1000, Math.floor(base * DPR)));
    for(let i=0;i<count;i++){
      particles.push({ x: Math.random()*W, y: Math.random()*H, vx:(Math.random()-0.5)*0.4, vy:(m==='snow'? (0.3+Math.random()*0.8):(6+Math.random()*12)), len:(m==='snow'? (2+Math.random()*5): (10+Math.random()*28)), size:(m==='snow'?1+Math.random()*2:1), rot:Math.random()*Math.PI*2 });
    }
  }
  function onResize(){ reset(); }
  function update(dt){
    const c = ctx.precip; c.clearRect(0,0,c.canvas.width,c.canvas.height);
    if(mode==='none') return;
    c.save();
    if(mode==='rain'){
      c.strokeStyle='rgba(255,255,255,0.45)'; c.lineWidth = 1*DPR;
      for(const p of particles){
        p.x += p.vx * dt * DPR; p.y += p.vy * dt * DPR;
        c.beginPath(); c.moveTo(p.x,p.y); c.lineTo(p.x - p.vx*1.5*DPR, p.y - p.len*DPR); c.stroke();
        if(p.y > c.canvas.height + 30*DPR){ p.x = Math.random()*c.canvas.width; p.y = -10*DPR - Math.random()*200*DPR; }
      }
    } else if(mode==='snow'){
      for(const p of particles){
        p.x += Math.sin(p.rot) * 0.4 * DPR + p.vx * dt * DPR; p.y += p.vy * 0.35 * dt * DPR; p.rot += 0.01;
        c.beginPath(); c.fillStyle='rgba(255,255,255,0.95)'; c.arc(p.x,p.y,p.size*DPR,0,Math.PI*2); c.fill();
        if(p.y > c.canvas.height + 20*DPR){ p.x = Math.random()*c.canvas.width; p.y = -10*DPR - Math.random()*200*DPR; }
      }
    }
    c.restore();
  }
  return { setMode, update, onResize };
})();

/* Lightning */
const lightning = (() => {
  let handle=null;
  function flash(str=0.9, dur=160){
    const c = ctx.flash; const w=c.canvas.width, h=c.canvas.height; const start=performance.now();
    function f(){
      const t = performance.now() - start; c.clearRect(0,0,w,h);
      const a = Math.max(0, str*(1 - t/dur));
      if(a<=0){ c.clearRect(0,0,w,h); return; }
      const grad = c.createRadialGradient(w*0.5, h*0.15, 10, w*0.5, h*0.15, Math.max(w,h));
      grad.addColorStop(0, `rgba(255,255,255,${a*0.9})`); grad.addColorStop(0.6, `rgba(255,255,255,${a*0.25})`); grad.addColorStop(1,'rgba(255,255,255,0)');
      c.fillStyle = grad; c.fillRect(0,0,w,h);
      requestAnimationFrame(f);
    }
    f();
  }
  function schedule(){ stop(); function loop(){ const delay = 1100 + Math.random()*3600; handle = setTimeout(()=>{ flash(0.9 + Math.random()*0.3, 120 + Math.random()*240); if(Math.random()>0.6) setTimeout(()=>flash(0.6 + Math.random()*0.4, 90 + Math.random()*220), 120 + Math.random()*280); loop(); }, delay); } loop(); }
  function stop(){ if(handle){ clearTimeout(handle); handle=null; } }
  return { flash, schedule, stop };
})();

/* Loop */
let lastTs = performance.now();
function frame(ts){
  const dt = Math.min(60, ts - lastTs) * 0.06; lastTs = ts;
  drawSky();
  cloudField.update(dt);
  precip.update(dt);
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

/* -------------------------
  Open-Meteo helpers
--------------------------*/
async function fetchWeather(lat, lon){
  const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&hourly=relativehumidity_2m,pressure_msl&timezone=auto`;
  const r = await fetch(url);
  if(!r.ok) throw new Error('open-meteo fetch failed');
  return r.json();
}
async function geocode(q){
  const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(q)}&count=1&language=ru`;
  const r = await fetch(url);
  if(!r.ok) throw new Error('geocode failed');
  return r.json();
}

/* UI nodes */
const ui = {
  place: $('#place'),
  loader: $('#loader'),
  tempCenter: $('#tempCenter'),
  weatherLabel: $('#weatherLabel'),
  chipTime: $('#chipTime'),
  chipCond: $('#chipCond'),
  miniValHum: $('#miniValHum'),
  miniValPres: $('#miniValPres'),
  miniValWind: $('#miniValWind'),
  miniValFeels: $('#miniValFeels'),
  btnFetch: $('#btnFetch'),
  cityInput: $('#cityInput'),
  unitSwitch: $('#unitSwitch'),
  autoTheme: $('#autoTheme'),
  summaryTemp: $('#summaryTemp'),
  summaryText: $('#summaryText'),
  sceneSelect: $('#sceneSelect'),
  refreshBtn: $('#refreshBtn')
};

/* Gauge math (big temp gauge) */
const minTemp = -25, maxTemp = 40;
const ARC_RADIUS = 120;
function polarToCartesian(cx, cy, r, angleDeg){
  const angleRad = (angleDeg-90) * Math.PI/180.0;
  return { x: cx + (r * Math.cos(angleRad)), y: cy + (r * Math.sin(angleRad)) };
}
function describeArc(cx, cy, r, startAngle, endAngle){
  const start = polarToCartesian(cx, cy, r, endAngle);
  const end = polarToCartesian(cx, cy, r, startAngle);
  const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
  return ["M", start.x, start.y, "A", r, r, 0, largeArcFlag, 0, end.x, end.y].join(" ");
}
function mapTempToAngle(temp){
  const minA = -120, maxA = 120;
  const clamped = Math.max(minTemp, Math.min(maxTemp, temp));
  const ratio = (clamped - minTemp) / (maxTemp - minTemp);
  return minA + ratio * (maxA - minA);
}

/* Render ticks for big gauge */
function renderTicks(){
  const ticksG = $('#ticks'); if(!ticksG) return;
  let out = '';
  const steps = 13;
  for(let i=0;i<=steps;i++){
    const t = minTemp + (i/steps)*(maxTemp-minTemp);
    const angle = mapTempToAngle(t);
    const a1 = polarToCartesian(0,0,ARC_RADIUS, angle);
    const a2 = polarToCartesian(0,0,ARC_RADIUS-10, angle);
    out += `<line x1="${a1.x}" y1="${a1.y}" x2="${a2.x}" y2="${a2.y}" stroke="rgba(255,255,255,0.08)" stroke-width="2"></line>`;
    if(i%3===0){
      const lab = polarToCartesian(0,0,ARC_RADIUS-28, angle);
      const val = Math.round(t);
      out += `<text x="${lab.x}" y="${lab.y+4}" font-size="10" fill="#cfe9e5" text-anchor="middle">${val}</text>`;
    }
  }
  ticksG.innerHTML = out;
}

/* Update big gauge visuals */
function updateGauge(tempC){
  const arcBg = $('#arc-bg'), arcFill = $('#arc-fill'), needleG = $('#needleG');
  const fullPath = describeArc(0,0,ARC_RADIUS,-120,120);
  arcBg.setAttribute('d', fullPath);
  const angle = mapTempToAngle(tempC);
  const fillPath = describeArc(0,0,ARC_RADIUS,-120, angle);
  arcFill.setAttribute('d', fillPath);
  needleG.setAttribute('transform', `rotate(${angle})`);
  // color can be controlled by gradient stops or CSS; we use stops in SVG defs
}

/* small mini-gauges (draw arc percent) */
function drawMiniGauge(svgEl, percent, color){
  svgEl.innerHTML = '';
  const ns = 'http://www.w3.org/2000/svg';
  const size = 100;
  const cx = size/2, cy = size/2, r = 36;
  const svgns = svgEl;
  // bg circle
  const bg = document.createElementNS(ns,'circle'); bg.setAttribute('cx',cx); bg.setAttribute('cy',cy); bg.setAttribute('r',r); bg.setAttribute('fill','none'); bg.setAttribute('stroke','rgba(255,255,255,0.06)'); bg.setAttribute('stroke-width','8'); svgns.appendChild(bg);
  // arc
  const startAngle = -110, endAngle = -110 + (220*percent);
  const d = describeArc(cx,cy,r,startAngle,endAngle);
  const path = document.createElementNS(ns,'path'); path.setAttribute('d', d); path.setAttribute('fill','none'); path.setAttribute('stroke', color); path.setAttribute('stroke-width','8'); path.setAttribute('stroke-linecap','round'); svgns.appendChild(path);
  // center text
  const txt = document.createElementNS(ns,'text'); txt.setAttribute('x',cx); txt.setAttribute('y',cy+4); txt.setAttribute('text-anchor','middle'); txt.setAttribute('font-size','12'); txt.setAttribute('fill','#e7fbf7'); txt.textContent = Math.round(percent*100) + '%'; svgns.appendChild(txt);
}

/* Utility mapping for colors */
function colorForTemp(t){
  if(t <= 0) return getComputedStyle(document.documentElement).getPropertyValue('--cold') || '#45b0ff';
  if(t <= 18) return getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#4ca1af';
  return getComputedStyle(document.documentElement).getPropertyValue('--danger') || '#ff6b6b';
}

/* Code-to-scene mapping */
function codeToScene(code){
  if([95,96,99].includes(code)) return 'thunder';
  if([61,63,65,80,81,82,51,53,55].includes(code)) return 'rain';
  if([71,73,75,77].includes(code)) return 'snow';
  if([2,3,45,48].includes(code)) return 'cloudy';
  return 'clear';
}

/* Apply scene (sets precip mode, skyState, lightning) */
function applyScene(scene){
  if(scene === 'clear'){ precip.setMode('none'); skyState.mode = ui.autoTheme.checked ? guessDayNight() : 'day'; lightning.stop(); }
  else if(scene === 'cloudy'){ precip.setMode('none'); skyState.mode = 'dusk'; lightning.stop(); }
  else if(scene === 'rain'){ precip.setMode('rain'); skyState.mode = 'dusk'; lightning.stop(); }
  else if(scene === 'thunder'){ precip.setMode('rain'); skyState.mode = 'night'; lightning.schedule(); }
  else if(scene === 'snow'){ precip.setMode('snow'); skyState.mode = 'dusk'; lightning.stop(); }
  // update theme bg
  updateThemeBackground();
}

/* Theme bg update */
function guessDayNight(){ const h=new Date().getHours(); if(h>=6 && h<18) return 'day'; if(h>=18 && h<20) return 'dusk'; return 'night'; }
function updateThemeBackground(){
  if(ui.autoTheme.checked){
    if(skyState.mode==='night') document.body.style.background = 'linear-gradient(180deg,#020617,#07121a)';
    else if(skyState.mode==='dusk') document.body.style.background = 'linear-gradient(180deg,#2b1f3a,#7a6b9b)';
    else document.body.style.background = 'linear-gradient(180deg,#09303a,#1e4870)';
  } else {
    document.body.style.background = 'linear-gradient(180deg,#07121a,#0b2430)';
  }
}

/* -------------------------
  Display weather
--------------------------*/
async function displayWeatherFor(lat, lon, label){
  ui.loader.style.display = 'inline-block';
  try{
    const data = await fetchWeather(lat, lon);
    if(!data || !data.current_weather) throw new Error('no data');
    const w = data.current_weather;
    // humidity & pressure from hourly arrays
    let humidity='—', pressure='—';
    if(data.hourly && data.hourly.time){
      const times = data.hourly.time;
      let idx = times.indexOf(w.time);
      if(idx === -1) idx = times.length - 1;
      if(data.hourly.relativehumidity_2m) humidity = data.hourly.relativehumidity_2m[idx] + '%';
      if(data.hourly.pressure_msl) pressure = data.hourly.pressure_msl[idx] + ' hPa';
    }
    const useF = ui.unitSwitch.checked;
    const tempC = Math.round(w.temperature);
    // update UI
    $('#tempCenter').textContent = useF ? `${Math.round(tempC*9/5+32)}°F` : `${tempC}°C`;
    $('#weatherLabel').textContent = (weatherDictionary[w.weathercode] || 'Неизвестно');
    ui.chipTime.textContent = w.time || '';
    ui.chipCond.textContent = `Код ${w.weathercode}`;
    ui.miniValHum.textContent = humidity;
    ui.miniValPres.textContent = pressure;
    ui.miniValWind.textContent = `${Math.round(w.windspeed)} м/ч`;
    ui.miniValFeels.textContent = `${Math.round(w.temperature)}°C`;
    $('#summaryTemp').textContent = `${Math.round(w.temperature)}°C`;
    $('#summaryText').textContent = `${weatherDictionary[w.weathercode] || 'Неизвестно'} · ветер ${Math.round(w.windspeed)} м/ч`;

    // big gauge update
    updateGauge(tempC);

    // mini gauge arcs (draw percentages)
    const humVal = (humidity==='—')?0:Math.min(100, parseFloat(humidity))/100;
    drawMiniGauge($('#gHum'), humVal, '#7ef0b8');
    // pressure: map 900..1100 to 0..1
    const pres = (pressure==='—')?1013: parseFloat((pressure+'').replace(/[^\d.-]/g,''));
    const presPct = Math.max(0, Math.min(1, (pres - 900)/200));
    drawMiniGauge($('#gPres'), presPct, '#ffd66b');
    // wind: 0..40 m/s
    const wind = Math.min(40, Math.max(0, parseFloat(w.windspeed || 0)));
    drawMiniGauge($('#gWind'), wind/40, '#9bd0ff');
    // feels: map relative to -25..40
    const feels = Math.max(minTemp, Math.min(maxTemp, Math.round(w.temperature)));
    drawMiniGauge($('#gFeels'), (feels - minTemp)/(maxTemp - minTemp), colorForTemp(feels));

    // place text
    ui.place.textContent = label || `${lat.toFixed(2)}, ${lon.toFixed(2)}`;

    // scene apply
    const scene = codeToScene(w.weathercode);
    // if user chose manual scene, prefer that
    const manual = $('#sceneSelect').value;
    if(manual === 'auto') applyScene(scene); else applyScene(manual);

    // save last loc
    saveLastLoc({lat, lon, place: label||''});
  }catch(e){
    console.error(e);
    $('#summaryText').textContent = 'Ошибка получения данных';
  }finally{
    ui.loader.style.display = 'none';
  }
}

/* small weather codes -> text */
const weatherDictionary = {
  0:"Ясно",1:"Преимущественно ясно",2:"Переменная облачность",3:"Пасмурно",
  45:"Туман",48:"Иней",51:"Слабый моросящий дождь",53:"Умеренный моросящий дождь",
  55:"Сильный моросящий дождь",61:"Слабый дождь",63:"Умеренный дождь",65:"Сильный дождь",
  71:"Слабый снег",73:"Умеренный снег",75:"Сильный снег",80:"Ливень",
  81:"Сильный ливень",82:"Очень сильный ливень",95:"Гроза",96:"Гроза с градом",99:"Сильная гроза с градом"
};

/* -------------------------
  Controls: geolocation / search
--------------------------*/
async function tryGeolocation(){
  if(!navigator.geolocation) return null;
  try{
    const pos = await new Promise((res, rej) => navigator.geolocation.getCurrentPosition(res, rej, {timeout:8000}));
    return {lat: pos.coords.latitude, lon: pos.coords.longitude};
  }catch(e){ return null; }
}

$('#btnFetch').addEventListener('click', async ()=>{
  const q = ui.cityInput.value.trim();
  if(!q){
    ui.loader.style.display = 'inline-block';
    try{
      const loc = await tryGeolocation();
      if(loc) await displayWeatherFor(loc.lat, loc.lon, 'Ваше местоположение');
      else $('#summaryText').textContent = 'Разрешите геолокацию или введите город';
    }finally{ ui.loader.style.display = 'none'; }
    return;
  }
  ui.loader.style.display = 'inline-block';
  try{
    const geo = await geocode(q);
    if(!geo || !geo.results || geo.results.length===0){ $('#summaryText').textContent = 'Город не найден'; }
    else {
      const r = geo.results[0];
      await displayWeatherFor(r.latitude, r.longitude, `${r.name}, ${r.country}`);
    }
  }catch(e){ console.error(e); $('#summaryText').textContent = 'Ошибка геокодирования' }
  finally{ ui.loader.style.display = 'none'; }
});

/* refresh & scene select */
$('#refreshBtn').addEventListener('click', ()=>{
  const last = loadLastLoc();
  if(last) displayWeatherFor(last.lat, last.lon, last.place||'');
});
$('#sceneSelect').addEventListener('change', ()=>{ const val = $('#sceneSelect').value; if(val==='auto'){ const last = loadLastLoc(); if(last) displayWeatherFor(last.lat, last.lon, last.place||''); } else applyScene(val); });

/* unit switch */
ui.unitSwitch.addEventListener('change', ()=>{
  const last = loadLastLoc();
  if(last) displayWeatherFor(last.lat, last.lon, last.place||'');
  savePrefs();
});
ui.autoTheme.addEventListener('change', ()=>{ updateThemeBackground(); savePrefs(); });

/* -------------------------
  Mini card expand (simple modal)
--------------------------*/
let expanded = null;
document.querySelectorAll('.mini').forEach(el=>{
  el.addEventListener('click', ()=>{
    const key = el.dataset.key;
    openExpanded(key);
  });
});
function openExpanded(key){
  if(expanded){ expanded.remove(); expanded = null; return; }
  const mapping = {
    humidity: {title:'Влажность', val: $('#miniValHum').textContent},
    pressure: {title:'Давление', val: $('#miniValPres').textContent},
    wind: {title:'Ветер', val: $('#miniValWind').textContent},
    feels: {title:'Ощущается', val: $('#miniValFeels').textContent}
  };
  const d = mapping[key] || {title:key, val:'—'};
  const el = document.createElement('div'); el.className='expanded';
  el.innerHTML = `<div class="close-x" id="closeX">✕</div><div style="font-weight:700;font-size:18px;margin-bottom:8px">${d.title}</div><div style="font-size:36px;font-weight:800">${d.val}</div><div class="small" style="margin-top:10px">Нажмите ✕ или вне, чтобы закрыть</div>`;
  document.body.appendChild(el); expanded = el;
  $('#closeX').addEventListener('click', ()=>{ if(expanded){ expanded.remove(); expanded = null; }});
  setTimeout(()=>{ window.addEventListener('click', outside); }, 40);
  function outside(ev){ if(expanded && !expanded.contains(ev.target)){ expanded.remove(); expanded=null; window.removeEventListener('click', outside); } }
}

/* -------------------------
  Persistence
--------------------------*/
const KEY = 'ahh_liquid_v1';
function savePrefs(){ const p = {unit: ui.unitSwitch.checked, auto: ui.autoTheme.checked, scene: $('#sceneSelect').value}; localStorage.setItem(KEY+'_prefs', JSON.stringify(p)); }
function loadPrefs(){ try{ const p = JSON.parse(localStorage.getItem(KEY+'_prefs')); if(p){ ui.unitSwitch.checked = !!p.unit; ui.autoTheme.checked = !!p.auto; if(p.scene) $('#sceneSelect').value = p.scene; } else ui.autoTheme.checked = true; }catch(e){ ui.autoTheme.checked = true; } }
function saveLastLoc(o){ localStorage.setItem(KEY+'_last', JSON.stringify(o)); }
function loadLastLoc(){ try{ return JSON.parse(localStorage.getItem(KEY+'_last')); }catch(e){ return null; } }

/* -------------------------
  Init & startup
--------------------------*/
function init(){
  resizeAll(); renderTicks(); loadPrefs();
  const last = loadLastLoc();
  if(last && last.lat && last.lon) displayWeatherFor(last.lat, last.lon, last.place||'Последняя локация');
  else { tryGeolocation().then(loc=>{ if(loc) displayWeatherFor(loc.lat, loc.lon, 'Ваше местоположение'); else $('#summaryText').textContent = 'Включи геолокацию или введи город'; }); }
}
window.addEventListener('load', ()=>init());

/* -------------------------
  Helpers
--------------------------*/
function debounce(fn,t){ let h; return (...a)=>{ clearTimeout(h); h=setTimeout(()=>fn(...a),t) } }

/* Render ticks for big gauge initially */
function renderTicks(){ const ticksG = $('#ticks'); if(!ticksG) return; let out=''; const steps = 13; for(let i=0;i<=steps;i++){ const t = minTemp + (i/steps)*(maxTemp-minTemp); const angle = mapTempToAngle(t); const a1 = polarToCartesian(0,0,ARC_RADIUS, angle); const a2 = polarToCartesian(0,0,ARC_RADIUS-10, angle); out += `<line x1="${a1.x}" y1="${a1.y}" x2="${a2.x}" y2="${a2.y}" stroke="rgba(255,255,255,0.08)" stroke-width="2"></line>`; if(i%3===0){ const lab = polarToCartesian(0,0,ARC_RADIUS-28, angle); const val = Math.round(t); out += `<text x="${lab.x}" y="${lab.y+4}" font-size="10" fill="#cfe9e5" text-anchor="middle">${val}</text>`; } } ticksG.innerHTML = out; }

/* end of script */
</script>
</body>
</html>
